# 2. 算法基础

## 2.1 插入排序

# 图

## 基本概念

度：和该顶点相连的边数；对有向图来说，顶点的出边条数成为出度，反之称为入度。

## 图的存储

### 邻接矩阵

```c++
G[i][j] //顶点i到j 不连接 = INF; 连接= 边权
```



### 邻接表--顶点个数1000以上

同一个顶点的所有出边放在一个列表，N个顶点对应N个列表，没有出边，对应空表。

邻接表只存放每条边的终点编号

```c++
vector <int> Adj[N];
```

邻接表存放每条边的终点编号和边权

```c++
struct Node{
    //边的终点编号
    int v;
    //边权
    int w;
};
vector <int> Adj[N];
```

## 图的遍历

### 深度优先搜索（DFS)

**定义：**沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并继续访问那些未访问分支结点。

**连通分量**：无向图中，两个顶点之间可以相互到达（可以通过一定路径间接到达）则称这两个顶点**连通**。任意两个顶点都连通，则称图G为**连通图**，其中的极大连通子图为**连通分量（连通块）**。（不要理解为最大的连通子图）

**强连通分量**：有向图中，两个顶点之间可以相互到达（可以通过一定路径间接到达）则称这两个顶点**强连通**。任意两个顶点都连通，则称图G为**强连通图**，其中的极大强连通子图为**强连通分量（连通块）**。

```c++
#include <stdio.h>
#include <vector>
using namespace std;

//最大顶点数
const int MAXN = 1000;
//无穷大 表示不能到达
const int INF = 1000000000;
//顶点个数
int n;
//邻接矩阵
int G[MAXN][MAXN];

//图G的邻接表
vector<int> Adj[MAXN];
//如果顶点i已被访问 则vis[i] = true
bool vis[MAXN] = {false};

/**
 * @Descripttion: 图的深度优先遍历-邻接矩阵实现
 * @param {int} u
 * @param {int} depth
 * @return {*}
 */
void DFS(int u, int depth)
{
	//访问u
	vis[u] = true;
	//访问u的邻接点
	for (int v = 0; v < n; v++)
	{
		if (vis[v] == false && G[u][v] != INF)
		{
			DFS(v, depth + 1);
		}
	}
}

/**
 * @Descripttion: 图的深度优先遍历-邻接表实现
 * @param {int} u 为当前访问的顶点标号 
 * @param {int} depth 深度
 * @return {*}
 */
void DFS(int u, int depth)
{
	vis[u] = true;
	//需要对u进行一些操作 可在此处处理
	for (int i = 0; i < Adj[u].size(); i++)
	{
		int v = Adj[u][i];
		if (vis[v] == false)
		{
			DFS(v, depth + 1);
		}
	}
}

//遍历图G
void DFSTrave()
{
	//对每个顶点u
	for (int u = 0; u < n; u++)
	{
		//如果u未被访问
		if (vis[u] == false)
		{
			//访问u和u所在的连通块 1表示初始为第一层
			DFS(u, 1);
		}
	}
}

```

### 广度优先搜索（BFS)

```c++

#include <stdio.h>
#include <queue>

using namespace std;

//当需要输出层时  就要存储结点
struct node
{
  //顶点的编号
  int v;
  //顶点层号
  int layer;
};
//最大顶点数
const int MAXN = 1000;
//无穷大 表示不能到达
const int INF = 1000000000;
//顶点数
int n;
//图的邻接矩阵
int G[MAXN][MAXN];
//图的邻接表
vector<int> Adj[MAXN];
vector<node> AdjNode[MAXN];

//如果顶点i已被访问 则inq[i] = true
bool inq[MAXN] = {false};

//图的遍历-邻接矩阵
void BFS(int u)
{
  queue<int> q;
  q.push(u);
  //设置u已被加入过队列
  inq[u] = true;
  while (!q.empty())
  {
    int u = q.front();
    //枚举u的所有相邻结点
    for (int v = 0; v < n; v++)
    {
      //如果u的领结点v未加入队列且通过u可达
      if (inq[v] == false && G[u][v] != INF)
      {
        q.push(v);
        inq[v] = true;
      }
    }
  }
}

//图的遍历-邻接表
void BFS(int u)
{
  queue<int> q;
  q.push(u);
  inq[u] = true;
  while (!q.empty())
  {
    q.front();
    for (int i = 0; i < Adj[u].size(); i++)
    {
      if (inq[Adj[u][i]] == false)
      {
        q.push(Adj[u][i]);
        inq[Adj[u][i]] = true;
      }
    }
  }
}

//考虑层号的输出
void BFS(int s)
{
  queue<node> q;
  node start;
  start.v = s;
  start.layer = 0;
  q.push(start);
  //起始点的编号设为已被加入队列
  inq[start.v] = true;
  while (!q.empty())
  {
    //取出队首元素
    node topNode = q.front();
    q.pop();
    int u = topNode.v;
    for (int i = 0; i < AdjNode[u].size(); i++)
    {
      //从u出发能到达的顶点
      node next = AdjNode[u][i];
      next.layer = topNode.layer + 1;
      if (inq[next.v] == false)
      {
        q.push(next);
        //next的编号设为已被加入过队列
        inq[next.v] = true;
      }
    }
  }
}

void BFSTrave()
{
  for (int u = 0; u < n; u++)
  {
    if (inq[u] == false)
    {
      BFS(u);
    }
  }
}
```

## 最短路径

### Dijkstra算法

#### 邻接矩阵实现

```c++
#include <stdio.h>
#include <algorithm>
#include <vector>
using namespace std;

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 1000000000;

//顶点数量 连接矩阵 起点到各点的最短路径长度 表示从起点到顶点v的最短路径上v的前一个顶点
int n, G[MAXV][MAXV], dis[MAXV], pre[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};

/**
 * @Descripttion: 连接矩阵实现
 * @param {int} s
 * @return {*}
 */
void Dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  //初始状态设置每个结点的前驱结点为自身
  for (int i = 0; i < n; i++)
  {
    pre[i] = i;
  }

  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF && dis[v] > G[u][v] + dis[u])
      {
        //优化dis[v]
        dis[v] = G[u][v] + dis[u];
        pre[v] = u;
      }
    }
  }
}

/**
 * @Descripttion: 输出路径
 * @param {int} s 起点
 * @param {int} v 终点
 * @return {*}
 */
void DFS(int s, int v)
{
  if (v == s)
  {
    printf("%d\n", s);
    return;
  }
  DFS(s, pre[v]);
  //从最深处return回来之后 输出每一层的顶点编号
  printf("%d\n", v);
}
```

#### 邻接表实现

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;

struct Node
{
  //v为边的目标顶点 dis为边权
  int v, dis;
};

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 1000000000;

//顶点数量 起点到各点的最短路径长度 表示从起点到顶点v的最短路径上v的前一个顶点
int n, dis[MAXV], pre[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};

vector<Node> Adj[MAXV];

void dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  //初始状态设置每个结点的前驱结点为自身
  for (int i = 0; i < n; i++)
  {
    pre[i] = i;
  }
  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int j = 0; j < Adj[u].size(); j++)
    {
      //如果v未被访问 && 以u为中介到达v距离更小
      int v = Adj[u][j].v;
      if (vis[v] == false && dis[v] > Adj[u][j].dis + dis[u])
      {
        //优化dis[v]
        dis[v] = dis[u] + Adj[u][j].dis;
      }
    }
  }
}

/**
 * @Descripttion: 输出路径
 * @param {int} s 起点
 * @param {int} v 终点
 * @return {*}
 */
void DFS(int s, int v)
{
  if (v == s)
  {
    printf("%d\n", s);
    return;
  }
  DFS(s, pre[v]);
  //从最深处return回来之后 输出每一层的顶点编号
  printf("%d\n", v);
}

```

#### 考虑第二标尺的最短路径

##### 新增边权

```c++
//cost[u][v]表示u->v的花费 由题目给出
//增加一个数组c[],表示从起点到达顶点u的最少花费为c[u],只有c[s]初始化为0，其余为INF
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          c[v] = c[u] + cost[u][v];
          pre[v] = u;
          num[v] = num[u];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v] && c[v] > c[u] + cost[u][v])
        {
          c[v] = c[u] + cost[u][v];
          pre[v] = u;
          num[v] += num[u];
        }
      }
    }
```

##### 新增点权

```c++
//weight[u]表示u可收集的物资 由题目给出
//增加一个数组w[],表示从起点到达顶点u可收集的最大物资w[u],只有w[s]初始化为weight[s]，其余为INF
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          w[v] = w[u] + weight[v];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v] && w[v] < w[u] + weight[v])
        {
          w[v] = w[u] + weight[v];         
        }
      }
    }
```

##### 最短路径条数

```c++
//num[]表示s->u的最短路径条数 s:起点
//num[s] = 1 其余为0
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          c[v] = c[u] + cost[u][v];
          pre[v] = u;
          num[v] = num[u];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v] && c[v] > c[u] + cost[u][v])
        {
          c[v] = c[u] + cost[u][v];
          pre[v] = u;
          num[v] += num[u];
        }
      }
    }
```

##### Dijkstra+DFS

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 1000000000;
//顶点数量 路径矩阵 起点
int n, G[MAXV][MAXV], st;
//起点到各点的最短路径长度 记录题目中添加的额外边权代价信息 从题目中获取
int dis[MAXV], cost[MAXV][MAXV], weight[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};
//表示从起点到顶点v的最短路径上v的前一个顶点
vector<int> pre[MAXV];

/**
 * @Descripttion: 连接矩阵实现
 * @param {int} s
 * @return {*}
 */
void Dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          pre[v].clear();
          pre[v].push_back(u);
        }
        else if (dis[v] == G[u][v] + dis[u])
        {
          pre[v].push_back(u);
        }
      }
    }
  }
}
//最优路径和临时路径
vector<int> path, tempPath;
//第二标尺最优值
int optValue;
/**
 * @Descripttion: 输出路径
 * @param {int} v 当前访问的结点
 * @return {*}
 */
void DFS(int v)
{
  //递归边界
  if (v == st) //到达了叶子结点
  {
    tempPath.push_back(v);
    int value;
    //此处添加计算第二标尺的value值
    //边权
    for (int i = tempPath.size() - 1; i > 0; i--)
    {
      //当前结点id 下一结点idNext
      int id = tempPath[i], idNext = tempPath[i - 1];
      value += cost[id][idNext];
    }
    //点权
    for (int i = tempPath.size() - 1; i >= 0; i--)
    {
      //当前结点id 下一结点idNext
      int id = tempPath[i];
      value += weight[id];
    }
    if (value < optValue)
    {
      optValue = value;
      path = tempPath;
    }
    //将刚加入的结点删除
    tempPath.pop_back();
    return;
  }
  //递归式
  tempPath.push_back(v);
  for (int i = 0; i < pre[v].size(); i++)
  {
    //结点v的前驱结点pre[v][i] 递归
    DFS(pre[v][i]);
  }

  //遍历完所有结点 删除v
  tempPath.pop_back();
}
```



# 散列表



## 直接寻址表

## 散列表

## 散列函数

### 除法散列法

### 乘法散列法

### 全域散列法

## 开放寻址法

### 线性探查法

不断探查后边的位置，超过表长时从表头开始，直达遇到空位置

缺点：元素容易扎堆

### 平方探查法

按照 H(key) + 1^2、H(key) - 1^2、H(key) + 2^2、H(key) - 2^2...如果超过了表长，就把H(key) + k^2对TSize(表长)取模，如果H(key) - k^2 < 0，将((H(key) - k^2) % TSize + TSize) % TSize作为结果(等价于H(key) - k^2 不断加上TSize，直到出现非负数)

## 完全散列

## 字符串hash

```c
//字符串全为大写字母的hash转换-->将26个字母等效成1-26
int hashFunc(int str[], int len){
	int val = 0;
    for(int i = 0; i < len; i++){
        val = val * 26 + (str[i] - 'A' );
    }
    return val;
}
```

# 递归

# 查找

## 二分查找

要求序列递增，时间复杂度为log(n)，二分查找过程与序列的下标从0或者1开始无关；

```c
//寻找递增数列arr中是否包含val
int binarySearch(int arr[], int right, int val)
{
    int left;
    int mid;
    while (left <= right)
    {
        // int mid = (left + right) / 2;
        mid = left + (right - left) / 2; //避免溢出
        if (arr[mid] == val)
            return mid;
        else if (arr[mid] > val)
            right = mid - 1;
        else
            left = mid + 1;
    }

    return -1;
}
```



# 算法笔记

## 1.入门模拟

## 1.1判断两个输入日期的差值

输入：

20130101

20130105

输出：

5

```c
//codeup1928日期差值
#include <stdio.h>
int months[13][2] = {{0, 0}, {31, 31}, {28, 29}, {31, 31}, {30, 30}, {31, 31}, {30, 30}, {31, 31}, 
 						{31, 31}, {30, 30}, {31, 31}, {30, 30}, {31, 31}};//平年和闰年每个月天数

//判断是否为闰年 
bool isLeap(int year){
	return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int main(){
	int time1, y1, m1, d1;
	int time2, y2, m2, d2;
	while(scanf("%d%d", &time1, &time2) != EOF){
		
		if(time1 > time2){ //如果第一个日期大于第二个 交换 
			int temp = time1;
			time1 = time2;
			time2 = temp;
		}
		//获取  年 月 日
		y1 = time1 / 10000, m1 = time1 % 10000 / 100, d1 = time1 % 100; 
		y2 = time2 / 10000, m2 = time2 % 10000 / 100, d2 = time2 % 100;
		int ans = 1;
		while((y1 < y2) || (m1 < m2) || (d1 < d2)){
			d1++; // 天数加1
			if(d1 == months[m1][isLeap(y1)] + 1){// 满当月天数
				m1++;
				d1 = 1;
			} 
			
			if(m1 == 13){ //月份满12个月 
				y1++;
				m1 = 1;
			}
			
			ans++; 
				 
		}
		printf("%d\n", ans);
	}
	
	return 0;
} 
  
```

## 1.2进制转换

P进制转为十进制

```c
int y = 0, product = 1;//product在循环中不断乘以P，得到1，P, P^2...
int P; P进制
while(x != 0){
    y = (x % 10) * product;
    x /= 10;
    product = product * P;
}
```

十进制转为P进制 ---除基取余法

```c
int res[maxn], index = 0;
do{
    res[index++] = y % Q;
    y = y / Q;
}while(y != 0);
//数组从高位到低位输出即可(逆序)
```

## 4.3全排列

按顺序往res的第1位到第n位填入数字，假设res[1]~res[index-1]已经填好，准备往res[index]位置填。此时，需要枚举1~n，如果当前值x没有在res[1]~res[index-1]中(hashTable[x] == false)，就在res[index]位置填入x，同时将hashTable[x]置为true，然后去处理 generateFullPermutation(index + 1);递归完成时,再将hashTable[x]还原为false。

```c
#include <stdio.h>
const int maxn = 11;
int n, res[maxn], hashTable[maxn] = {false}; //n的全排列 res全排列的结果 hashTable记录x是否已存在

//当前处理第index位
void generateFullPermutation(int index)
{
    if (index == n + 1){ //递归边界
        for (int i = 1; i < n + 1; i++)
        {
            printf("%d ", res[i]); //输出当前排列
        }
        printf("\n");
        return;
    }

    for (int x = 1; x < n + 1; x++) //枚举1~n，试图将x放入res数组中
    {
        if(hashTable[x] == false){ //如果x不在res[0]~res[1]
            res[index] = x; 
            hashTable[x] = true;
            generateFullPermutation(index + 1); //处理index+1
            hashTable[x] = false; //所有位置处理完 重置hashTable
        }
    }
    
}

int main(){
    n = 3;
    generateFullPermutation(1);
    return 0;
}
```

## 4.4 二分查找拓展

递增序列A中可能存在重复元素，对于给定的欲查询的元素x，求出序列中第一个大于等于x的元素的位置L以及第一个大于X的元素的位置R

**求出序列中第一个大于等于x的元素的位置L**

```c

int binarySearch(int arr[], int right, int val)
{
    int left;
    int mid;
    while (left < right) //二分查找算法当数组中不存在元素val时，返回-1，而求出序列中第一个大于等于x的元素的位置L必须返回一个位置，即使不存在，返回的也是“假设他存在，他应该在的位置”，而left==right刚好是要返回的结果（退出while循环）
    {
        // int mid = (left + right) / 2;
        mid = left + (right - left) / 2; //避免溢出
       if (arr[mid] >= val)
            right = mid;
        else
            left = mid + 1;
    }

    return -1;
}
```

第一个大于X的元素的位置R

```c

int binarySearch(int arr[], int right, int val)
{
    int left;
    int mid;
    while (left < right) //二分查找算法当数组中不存在元素val时，返回-1，而求出序列中第一个大于等于x的元素的位置L必须返回一个位置，即使不存在，返回的也是“假设他存在，他应该在的位置”，而left==right刚好是要返回的结果（退出while循环）
    {
        // int mid = (left + right) / 2;
        mid = left + (right - left) / 2; //避免溢出
       if (arr[mid] > val)
            right = mid;
        else
            left = mid + 1;
    }

    return -1;
}
```

**寻找有序序列中第一个满足某条件的元素的位置**

```c
//二分区间为左闭右闭的[left, right],初值必须能覆盖的所有可能取值
int solve(int left, int right){
    int mid; 
    while(left < right){
        mid = (left + right) / 2; //取中点
        if(条件成立){ //条件成立，第一个满足条件的元素的位置<=mid
            right = mid; //往左子区间[left, mid]查找
        }else{ //条件不成立，则第一个满足该条件的元素的位置 >mid
            left = mid + 1;
        }
    }
    return left;
}
```

