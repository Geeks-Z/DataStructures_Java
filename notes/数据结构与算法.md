参考数目《算法笔记》、《算法导论》

参考网络资源： https://github.com/CyC2018/CS-Notes

- [排序](#排序)
  - [冒泡排序](#冒泡排序)
  - [选择排序](#选择排序)
  - [插入排序](#插入排序)
  - [希尔排序](#希尔排序)
  - [归并排序](#归并排序)
    - [1. 归并方法](#1-归并方法)
    - [2. 自顶向下归并排序](#2-自顶向下归并排序)
    - [3. 自底向上归并排序](#3-自底向上归并排序)
    - [4. 归并排序思想示意图](#4-归并排序思想示意图)
    - [5. 代码实现](#5-代码实现)
      - [C++代码](#c代码)
      - [Java代码](#java代码)
  - [快速排序](#快速排序)
    - [1. 基本算法](#1-基本算法)
    - [2. 切分](#2-切分)
    - [3. 性能分析](#3-性能分析)
    - [4. 算法改进](#4-算法改进)
        - [4.1 切换到插入排序](#41-切换到插入排序)
        - [4.2 三数取中](#42-三数取中)
        - [4.3 三向切分](#43-三向切分)
    - [5. 基于切分的快速选择算法](#5-基于切分的快速选择算法)
    - [6. 代码实现](#6-代码实现)
  - [堆排序](#堆排序)
    - [1. 堆](#1-堆)
    - [2. 上浮和下沉](#2-上浮和下沉)
    - [3. 插入元素](#3-插入元素)
    - [4. 删除最大元素](#4-删除最大元素)
    - [5. 堆排序](#5-堆排序)
        - [5.1 构建堆](#51-构建堆)
        - [5.2 交换堆顶元素与最后一个元素](#52-交换堆顶元素与最后一个元素)
    - [6. C代码](#6-c代码)
    - [7. 分析](#7-分析)
  - [qsort（C）](#qsortc)
  - [sort（C++）](#sortc)
  - [小结](#小结)
    - [1. 排序算法的比较](#1-排序算法的比较)
    - [2. Java 的排序算法实现](#2-java-的排序算法实现)
- [图](#图)
  - [基本概念](#基本概念)
  - [图的存储](#图的存储)
    - [邻接矩阵](#邻接矩阵)
    - [邻接表--顶点个数 1000 以上](#邻接表--顶点个数-1000-以上)
  - [图的遍历](#图的遍历)
    - [深度优先搜索（DFS)](#深度优先搜索dfs)
    - [广度优先搜索（BFS)](#广度优先搜索bfs)
  - [最短路径](#最短路径)
    - [Dijkstra 算法](#dijkstra-算法)
      - [邻接矩阵实现](#邻接矩阵实现)
      - [邻接表实现](#邻接表实现)
      - [考虑第二标尺的最短路径](#考虑第二标尺的最短路径)
        - [新增边权](#新增边权)
        - [新增点权](#新增点权)
        - [最短路径条数](#最短路径条数)
        - [Dijkstra+DFS](#dijkstradfs)
    - [Bellman-Ford 算法](#bellman-ford-算法)
  - [最小生成树](#最小生成树)
    - [prim 算法--边多的情况](#prim-算法--边多的情况)
      - [邻接矩阵版](#邻接矩阵版)
      - [邻接表版](#邻接表版)
    - [kruskal 算法--点多的情况](#kruskal-算法--点多的情况)
      - [基本思想](#基本思想)
      - [代码实现](#代码实现)
    - [拓扑排序](#拓扑排序)
      - [实现步骤](#实现步骤)
      - [代码实现](#代码实现-1)
    - [关键路径](#关键路径)
      - [AOV 网（Activity On Vertex）](#aov-网activity-on-vertex)
      - [AOE 网（Activity On Edge）](#aoe-网activity-on-edge)
      - [关键路径](#关键路径-1)
- [树](#树)
  - [二叉树基本操作](#二叉树基本操作)
  - [二叉树的遍历](#二叉树的遍历)
  - [静态写法](#静态写法)
  - [二叉查找树（BST)](#二叉查找树bst)
    - [**二叉排序树介绍**](#二叉排序树介绍)
    - [基本操作](#基本操作)
  - [平衡二叉树(AVL)](#平衡二叉树avl)
    - [平衡二叉树介绍](#平衡二叉树介绍)
    - [基本操作](#基本操作-1)
- [并查集](#并查集)
  - [前言](#前言)
  - [Find](#find)
  - [Quick Find](#quick-find)
  - [Union](#union)
  - [Quick Union](#quick-union)
  - [加权 Quick Union](#加权-quick-union)
  - [路径压缩](#路径压缩)
  - [路径压缩的加权 Quick Union](#路径压缩的加权-quick-union)
  - [比较](#比较)
- [散列表](#散列表)
  - [直接寻址表](#直接寻址表)
  - [散列表](#散列表-1)
  - [散列函数](#散列函数)
    - [除法散列法](#除法散列法)
    - [乘法散列法](#乘法散列法)
    - [全域散列法](#全域散列法)
  - [Hash 冲突解决](#hash-冲突解决)
    - [开放寻址法](#开放寻址法)
      - [线性探查法](#线性探查法)
      - [平方探查法](#平方探查法)
    - [链地址法](#链地址法)
  - [完全散列](#完全散列)
  - [字符串 hash](#字符串-hash)
- [递归](#递归)
  - [递归边界](#递归边界)
  - [递归式](#递归式)
- [查找](#查找)
- [二分法](#二分法)
  - [二分查找](#二分查找)
  - [模板](#模板)
- [贪心算法](#贪心算法)
- [动态规划算法](#动态规划算法)
- [回溯法](#回溯法)
# 排序

从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 \~N<sup>2</sup>/2 次比较和 \~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bc6be2d0-ed5e-4def-89e5-3ada9afa811a.gif" width="230px"> </div><br>

```java
public class Selection<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i < N - 1; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(nums[j], nums[min])) {
                    min = j;
                }
            }
            swap(nums, i, min);
        }
    }
}
```

## 冒泡排序

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。

在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f8d178b-52d8-491b-9dfd-41e05a952578.gif" width="200px"> </div><br>

```java
public class Bubble<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        for (int i = N - 1; i > 0 && !isSorted; i--) {
            isSorted = true;
            for (int j = 0; j < i; j++) {
                if (less(nums[j + 1], nums[j])) {
                    isSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
}
```

## 选择排序

1. **基本介绍**

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

2. **选择排序思想**

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：

**第一次**从 arr[**0**]~arr[**n-1**]中**选取最小值**，与 arr[**0**]交换；

**第二次**从 arr[**1**]~arr[**n-1**]中**选取最小值**，与 arr[**1**]交换；

**第三次**从 arr[**2**]~arr[**n-1**]中**选取最小值**，与 arr[**2**]交换；

……

**第 i 次**从 arr[**i-1**]~arr[**n-1**]中**选取最小值**，与 arr[**i-1**]交换；

**第 n-1 次**从 arr[**n-2**]~arr[**n-1**]中选取最小值，与 arr[**n-2**]交换；

**总共**通过**n-1**次，得到一个按排序码从小到大排列的有序序列。

3. **代码**

   ```c
   void selectSort(int arr[], int len)
   {
     for (int i = 0; i < len - 1; i++)
     {
       int minVal = arr[i];
       int minIndex = i;
       for (int insertIndex = i + 1; insertIndex < len; insertIndex++)
       {
         if (arr[insertIndex] < minVal)
         {
           minVal = arr[insertIndex + 1];
           minIndex = insertIndex + 1;
         }
       }
       //交换arr[i] 与 minVal
       arr[minIndex] = arr[i];
       arr[i] = minVal;
     }
   }
   ```

## 插入排序

1. **插入排序法介绍**

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

2. **插入排序法思想**

插入排序（Insertion Sorting）的**基本思想**是：把 n 个待排序的元素看成为一个**有序表**和一个**无序表**，开始时有序表中**只包含一个元素**，无序表中包含有**n-1**个元素，排序过程中每次从无序表中**取出第一个元素**，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35253fa4-f60a-4e3b-aaec-8fc835aabdac.gif" width="200px"> </div><br>

3. **时间复杂度**
   - 平均情况下插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
   - 最坏的情况下需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
   - 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

```c
void insertSort(int arr[], int len)
{
  for (int i = 1; i < len; i++)
  {
    //待插入的位置
    int insertIndex = i - 1;
    //寻找插入位置
    while (insertIndex >= 0 && arr[insertIndex] > arr[i])
    {
      arr[insertIndex + 1] = arr[insertIndex];
      insertIndex--;
    }
    arr[insertIndex + 1] = arr[i];
  }
}
```

## 希尔排序

对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png" width="450px"> </div><br>

```java
public class Shell<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {

        int N = nums.length;
        int h = 1;

        while (h < N / 3) {
            h = 3 * h + 1; // 1, 4, 13, 40, ...
        }

        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(nums[j], nums[j - h]); j -= h) {
                    swap(nums, j, j - h);
                }
            }
            h = h / 3;
        }
    }
}

```

希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ...  的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。

## 归并排序

归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png" width="300px"> </div><br>

### 1. 归并方法

归并方法将数组中两个已经排序的部分归并成一个。归并排序（MERGE-SORT）是利用**归并的思想**实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）**策略**（分治法将问题分(divide)成一些小的问题然后**递归求解**，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

```java
public abstract class MergeSort<T extends Comparable<T>> extends Sort<T> {

    protected T[] aux;


    protected void merge(T[] nums, int l, int m, int h) {

        int i = l, j = m + 1;

        for (int k = l; k <= h; k++) {
            aux[k] = nums[k]; // 将数据复制到辅助数组
        }

        for (int k = l; k <= h; k++) {
            if (i > m) {
                nums[k] = aux[j++];

            } else if (j > h) {
                nums[k] = aux[i++];

            } else if (aux[i].compareTo(aux[j]) <= 0) {
                nums[k] = aux[i++]; // 先进行这一步，保证稳定性

            } else {
                nums[k] = aux[j++];
            }
        }
    }
}
```

### 2. 自顶向下归并排序

将一个大数组分成两个小数组去求解。

因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。

```java
public class Up2DownMergeSort<T extends Comparable<T>> extends MergeSort<T> {

    @Override
    public void sort(T[] nums) {
        aux = (T[]) new Comparable[nums.length];
        sort(nums, 0, nums.length - 1);
    }

    private void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int mid = l + (h - l) / 2;
        sort(nums, l, mid);
        sort(nums, mid + 1, h);
        merge(nums, l, mid, h);
    }
}
```


### 3. 自底向上归并排序

先归并那些微型数组，然后成对归并得到的微型数组。

```java
public class Down2UpMergeSort<T extends Comparable<T>> extends MergeSort<T> {

    @Override
    public void sort(T[] nums) {

        int N = nums.length;
        aux = (T[]) new Comparable[N];

        for (int sz = 1; sz < N; sz += sz) {
            for (int lo = 0; lo < N - sz; lo += sz + sz) {
                merge(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
            }
        }
    }
}

```

### 4. 归并排序思想示意图

![](数据结构与算法.assets/归并排序分治.png)

![](数据结构与算法.assets/归并排序合1.png)

![](数据结构与算法.assets/归并排序合2.png)

### 5. 代码实现

#### C++代码

```c++

void merge(int arr[], int l1, int r1, int l2, int r2)
{
  int i = l1, j = l2;
  int temp[r2 - i + 1];
  int index = 0;
  while (i <= r1 && j <= r2)
  {
    if (arr[i] <= arr[j])
    {
      temp[index++] = arr[i++];
    }
    else
    {
      temp[index++] = arr[j++];
    }
  }
  //左子数组有剩余
  while (i <= r1)
  {
    temp[index++] = arr[i++];
  }
  while (j <= r2)
  {
    temp[index++] = arr[j++];
  }
  //重新写回数组arr
  for (int i = 0; i < index; i++)
  {
    arr[l1 + i] = temp[i];
  }
}

void mergeSort(int arr[], int l, int r)
{
  if (l < r)
  {
    int mid = (int)floor(1.0 * (r + l) / 2);
    //将左子区间[left,mid]归并排序
    mergeSort(arr, l, mid);
    //将右子区间[mid,right]归并排序
    mergeSort(arr, mid + 1, r);
    //将左子区间和右子区间合并
    merge(arr, l, mid, mid + 1, r);
  }
}


```

#### Java代码

```java
		public static void mergeSort(int[] arr, int left, int right, int[] temp) {
				if(left < right) {
					int mid = (left + right) / 2; //中间索引
					//向左递归进行分解
					mergeSort(arr, left, mid, temp);
					//向右递归进行分解
					mergeSort(arr, mid + 1, right, temp);
					//合并
					merge(arr, left, mid, right, temp);
				}
			}
			//合并的方法
			/**
			 *
			 * @param arr 排序的原始数组
			 * @param left 左边有序序列的初始索引
			 * @param mid 中间索引
			 * @param right 右边索引
			 * @param temp 做中转的数组
			 */
			public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
				int i = left; // 初始化i, 左边有序序列的初始索引
				int j = mid + 1; //初始化j, 右边有序序列的初始索引
				int t = 0; // 指向temp数组的当前索引
				//(一)
				//先把左右两边(有序)的数据按照规则填充到temp数组
				//直到左右两边的有序序列，有一边处理完毕为止
				while (i <= mid && j <= right) {//继续
					//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
					//即将左边的当前元素，填充到 temp数组
					//然后 t++, i++
					if(arr[i] <= arr[j]) {
						temp[t] = arr[i];
						t += 1;
						i += 1;
					} else { //反之,将右边有序序列的当前元素，填充到temp数组
						temp[t] = arr[j];
						t += 1;
						j += 1;
					}
				}
				//(二)
				//把有剩余数据的一边的数据依次全部填充到temp
				while( i <= mid) { //左边的有序序列还有剩余的元素，就全部填充到temp
					temp[t] = arr[i];
					t += 1;
					i += 1;
				}
				while( j <= right) { //右边的有序序列还有剩余的元素，就全部填充到temp
					temp[t] = arr[j];
					t += 1;
					j += 1;
				}
				//(三)
				//将temp数组的元素拷贝到arr
				//注意，并不是每次都拷贝所有
				t = 0;
				int tempLeft = left; //
				//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3
				//最后一次 tempLeft = 0  right = 7
				while(tempLeft <= right) {
					arr[tempLeft] = temp[t];
					t += 1;
					tempLeft += 1;
				}
			}
		}

```

## 快速排序

### 1. 基本算法

**快速排序**（Quicksort）是对**冒泡排序的一种改进**。**基本思想**是：通过一趟排序将要排序的数据**分割**成独立的**两部分**，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

- 归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；
- 快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png" width="280px"> </div><br>

```java
public class QuickSort<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        shuffle(nums);
        sort(nums, 0, nums.length - 1);
    }

    private void sort(T[] nums, int l, int h) {
        if (h <= l)
            return;
        int j = partition(nums, l, h);
        sort(nums, l, j - 1);
        sort(nums, j + 1, h);
    }

    private void shuffle(T[] nums) {
        List<Comparable> list = Arrays.asList(nums);
        Collections.shuffle(list);
        list.toArray(nums);
    }
}
```

### 2. 切分

取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c4859290-e27d-4f12-becf-e2a5c1f3a275.gif" width="320px"> </div><br>

```java
private int partition(T[] nums, int l, int h) {
    int i = l, j = h + 1;
    T v = nums[l];
    while (true) {
        while (less(nums[++i], v) && i != h) ;
        while (less(v, nums[--j]) && j != l) ;
        if (i >= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}
```

### 3. 性能分析

快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。

快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C<sub>N</sub>=2C<sub>N/2</sub>+N，复杂度为 O(NlogN)。

最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N<sup>2</sup>/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。

### 4. 算法改进

##### 4.1 切换到插入排序

因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

##### 4.2 三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。

##### 4.3 三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。

```java
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {

    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0) {
                swap(nums, lt++, i++);
            } else if (cmp > 0) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}
```

### 5. 基于切分的快速选择算法

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。

可以利用这个特性找出数组的第 k 个元素。

该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。

```java
public T select(T[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (h > l) {
        int j = partition(nums, l, h);

        if (j == k) {
            return nums[k];

        } else if (j > k) {
            h = j - 1;

        } else {
            l = j + 1;
        }
    }
    return nums[k];
}
```



### 6. 代码实现

```c

/**
 * @Descripttion: 根据第一个元素划分数组
 * @param {int} arr
 * @param {int} left
 * @param {int} right
 * @return {*}
 */
int partition(int arr[], int left, int right)
{
  int temp = arr[left];
  while (left < right)
  {
    while (left < right && arr[right] > temp)
    {
      right--;
    }
    arr[left] = arr[right];
    while (left < right && arr[left] < temp)
    {
      left++;
    }
    arr[right] = arr[left];
  }
  arr[left] = temp;
  //返回相遇的下标
  return left;
}

/**
 * @Descripttion: 随即确定一个元素划分数组
 * @param {int} arr
 * @param {int} left
 * @param {int} right
 * @return {*}
 */
int randPartition(int arr[], int left, int right)
{
  //生成[left,right]范围内的数
  int random = rand() % (right - left + 1) + left;
  swap(arr[random], arr[left]);
  int temp = arr[left];
  while (left < right)
  {
    while (left < right && arr[right] > temp)
    {
      right--;
    }
    arr[left] = arr[right];
    while (left < right && arr[left] < temp)
    {
      left++;
    }
    arr[right] = arr[left];
  }
  arr[left] = temp;
  //返回相遇的下标
  return left;
}

void quickSort(int arr[], int left, int right)
{
  //当前区间长度超过1
  if (left < right)
  {
    int pos = partition(arr, left, right);
    //对左子区间递归进行快速排序
    quickSort(arr, left, pos - 1);
    //对右子区间递归进行快速排序
    quickSort(arr, pos + 1, right);
  }
}

int main(){
  //生成随机数的种子
  srand((unsigned)time(NULL));
  for (int i = 0; i < 10; i++)
  {
    printf("%d ", rand());
  }
  printf("\n");
  //生成[a,b]内的随机数
  for (int i = 0; i < 10; i++)
  {
    //s[3,7]内的随机数
    printf("%d ", rand() % 5 + 3);
  }

  return 0;
}
```

## 堆排序

### 1. 堆

堆中某个节点的值总是大于等于或小于等于其子节点的值，并且**堆是一颗完全二叉树**。

堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png" width="170px"> </div><br>

```java
public class Heap<T extends Comparable<T>> {

    private T[] heap;
    private int N = 0;

    public Heap(int maxN) {
        this.heap = (T[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    private boolean less(int i, int j) {
        return heap[i].compareTo(heap[j]) < 0;
    }

    private void swap(int i, int j) {
        T t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
    }
}
```

### 2. 上浮和下沉

在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99d5e84e-fc2a-49a3-8259-8de274617756.gif" width="270px"> </div><br>

```java
private void swim(int k) {
    while (k > 1 && less(k / 2, k)) {
        swap(k / 2, k);
        k = k / 2;
    }
}
```

类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4bf5e3fb-a285-4138-b3b6-780956eb1df1.gif" width="270px"> </div><br>

```java
private void sink(int k) {
    while (2 * k <= N) {
        int j = 2 * k;
        if (j < N && less(j, j + 1))
            j++;
        if (!less(k, j))
            break;
        swap(k, j);
        k = j;
    }
}
```

### 3. 插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

```java
public void insert(Comparable v) {
    heap[++N] = v;
    swim(N);
}
```

### 4. 删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

```java
public T delMax() {
    T max = heap[1];
    swap(1, N--);
    heap[N + 1] = null;
    sink(1);
    return max;
}
```

### 5. 堆排序

把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。

##### 5.1 构建堆

无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif" width="210px"> </div><br>

##### 5.2 交换堆顶元素与最后一个元素

交换之后需要进行下沉操作维持堆的有序状态。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d156bcda-ac8d-4324-95e0-0c8df41567c9.gif" width="250px"> </div><br>

```java
public class HeapSort<T extends Comparable<T>> extends Sort<T> {
    /**
     * 数组第 0 个位置不能有元素
     */
    @Override
    public void sort(T[] nums) {
        int N = nums.length - 1;
        for (int k = N / 2; k >= 1; k--)
            sink(nums, k, N);

        while (N > 1) {
            swap(nums, 1, N--);
            sink(nums, 1, N);
        }
    }

    private void sink(T[] nums, int k, int N) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(nums, j, j + 1))
                j++;
            if (!less(nums, k, j))
                break;
            swap(nums, k, j);
            k = j;
        }
    }

    private boolean less(T[] nums, int i, int j) {
        return nums[i].compareTo(nums[j]) < 0;
    }
}
```

### 6. C代码

```c
#include <stdio.h>
/**
 * @Descripttion: 
 * @param {int} arr
 * @param {int} low 预调整元素下标
 * @param {int} high 最后一个元素
 * @return {*}
 */
void downAdjust(int arr[], int low, int high)
{
  //i保存当前需要调整的结点 j保存左子结点
  int i = low, j = i * 2;
  while (j <= high)
  {
    if (j + 1 <= high && arr[j + 1] > arr[j])
    {
      //j保存右子结点下标
      j = j + 1;
    }
    if (arr[i] < arr[j])
    {
      swap(arr[i], arr[j]);
      //保持 i 为当前调整结点 j为左子结点
      i = j;
      j = 2 * i;
    }
    else
    {
      break;
    }
  }
}

/**
 * @Descripttion: 向上调整
 * @param {int} arr
 * @param {int} low
 * @param {int} high
 * @return {*}
 */
void upAdjust(int arr[], int low, int high)
{
  int i = high, j = i / 2;
  while (j >= low)
  {
    if (arr[j] < arr[i])
    {
      swap(arr[i], arr[j]);
      i = j;
      j = i / 2;
    }
    else
    {
      break;
    }
  }
}

/**
 * @Descripttion: 从最后一个非叶子结点开始调整
 * @param {int} arr
 * @param {int} len 数组长度
 * @return {*}
 */
void creatHeap(int arr[], int len)
{
  for (int i = len / 2; i >= 1; i--)
  {
    downAdjust(arr, i, len);
  }
}

void deleteTop(int arr[], int len)
{
  //用最后一个元素覆盖堆顶元素 并让元素减1
  arr[1] = arr[len--];
  downAdjust(arr, 1, len);
}

void insert(int arr[], int len, int x)
{
  //让元素个数加1 然后将数组末位赋值为x
  arr[len++] = x;
  //向上调整新加入的结点
  upAdjust(arr, 1, len);
}

void heapSort(int arr[]){
  int len = sizeof(arr) / sizeof(arr[0]);
  creatHeap(arr, len);
  //倒着枚举 直到堆中只有一个元素
  for (int i = len; i > 1; i--)
  {
    //交换堆顶 与 arr[i];
    swap(arr[1], arr[i]);
    //调整堆顶
    downAdjust(arr, 1, i - 1);
  }
  
}
```



### 7. 分析

一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

堆排序是一种原地排序，没有利用额外的空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。

## qsort（C）

```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```

```c

#include <stdio.h>
#include <stdlib.h>
int values[] = { 88, 56, 100, 2, 25 };

int cmpfunc (const void * a, const void * b)
{
   //可能溢出
   return ( *(int*)a - *(int*)b );
   /**int small_negative_val = (int)(0x80000000); // -2147483648
   int big_positive_val = 0x7fffffff; // 2147483647
   printf("%d", cmpfunc(&small_negative_val, &big_positive_val));
   //输出1。负数减正数却得出了正数，代表结果已经溢出，不再可靠。*/
}
//避免溢出
int cmpfunc (const void * a, const void * b)
{
    const int *aa = a;
    const int *bb = b;
    if (*aa < *bb)
        return -1;
    else if (*aa > *bb)
        return 1;
    else
        return 0;
}
int main()
{
   int n;

   printf("排序之前的列表：\n");
   for( n = 0 ; n < 5; n++ ) {
      printf("%d ", values[n]);
   }

   qsort(values, 5, sizeof(int), cmpfunc);

   printf("\n排序之后的列表：\n");
   for( n = 0 ; n < 5; n++ ) {
      printf("%d ", values[n]);
   }

  return(0);
}

//结构体排序
#include <iostream>
#include <stdlib.h>
#include <string.h>
using namespace std;
#define NUM 5
struct Student{
    unsigned ID;
    char szName[20];
    float fGPA;
};
Student MyClass[NUM]={
    {1234,"Tom",3.78},
    {1345,"Sam",2.12},
    {1235,"Bob",4.77},
    {1456,"Echo",1.34},
    {1578,"Amy",3.04},
};

int IDCompare(const void * elem1,const void * elem2)
{
    Student * stu1 = (Student*)elem1;
    Student * stu2 = (Student*)elem2;
    return (*stu1).ID-(*stu2).ID;
}
int NameCompare(const void * elem1, const void * elem2)
{
    Student * stu1 = (Student*)elem1;
    Student * stu2 = (Student*)elem2;
    return strcmp(stu1->szName,stu2->szName);
}
int main()
{
    qsort(MyClass,NUM,sizeof(Student),IDCompare);
    for(int i=0;i<NUM;i++)
        cout<<MyClass[i].szName<<" ";
    cout<<endl;
    qsort(MyClass,NUM,sizeof(Student),NameCompare);
    for(int i=0;i<NUM;i++)
        cout<<MyClass[i].szName<<" ";
    return 0;
}
```

参数

- **base** -- 指向要排序的数组的第一个元素的指针。
- **nitems** -- 由 base 指向的数组中元素的个数。
- **size** -- 数组中每个元素的大小，以字节为单位。
- **compar** -- 用来比较两个元素的函数。

compar 参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是 **const void \*** 型，同时在调用 compar 函数（compar 实质为函数指针，这里称它所指向的函数也为 compar）时，传入的实参也必须转换成**const void \*** 型。在 compar 函数内部会将 **const void \*** 型转换成实际类型，见下文。

```c
int compar(const void *p1, const void *p2);
```

如果 compar 返回值小于 0（< 0），那么 p1 所指向元素会被排在 p2 所指向元素的前面；如果 compar 返回值等于 0（= 0），那么 p1 所指向元素与 p2 所指向元素的顺序不确定；如果 compar 返回值大于 0（> 0），那么 p1 所指向元素会被排在 p2 所指向元素的后面。

返回值

该函数不返回任何值。

## sort（C++）



## 小结

### 1. 排序算法的比较

|       算法       | 稳定性 |          时间复杂度          | 空间复杂度 |           备注           |
| :--------------: | :----: | :--------------------------: | :--------: | :----------------------: |
|     选择排序     |   ×    |        N<sup>2</sup>         |     1      |                          |
|     冒泡排序     |   √    |        N<sup>2</sup>         |     1      |                          |
|     插入排序     |   √    |      N \~ N<sup>2</sup>      |     1      | 时间复杂度和初始顺序有关 |
|     希尔排序     |   ×    | N 的若干倍乘于递增序列的长度 |     1      |      改进版插入排序      |
|     快速排序     |   ×    |            NlogN             |    logN    |                          |
| 三向切分快速排序 |   ×    |          N \~ NlogN          |    logN    |   适用于有大量重复主键   |
|     归并排序     |   √    |            NlogN             |     N      |                          |
|      堆排序      |   ×    |            NlogN             |     1      |    无法利用局部性原理    |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 \~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

### 2. Java 的排序算法实现

Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。 

# 图

参考《算法导论》 《算法笔记》

## 基本概念

度：和该顶点相连的边数；对有向图来说，顶点的出边条数称为出度，反之称为入度。

## 图的存储

### 邻接矩阵

```c++
G[i][j] //顶点i到j 不连接 = INF; 连接 = 边权
```

### 邻接表

同一个顶点的所有出边放在一个列表，N 个顶点对应 N 个列表，没有出边，对应空表。（顶点个数 1000 以上）

邻接表只存放每条边的终点编号

```c++
vector <int> Adj[N];
```

邻接表存放每条边的终点编号和边权

```c++
struct Node{
    //边的终点编号
    int v;
    //边权
    int w;
    //定义构造函数 
    Node(int _v, int _w){
        v = _v;
        w = _w;
    }
};
vector <Node> Adj[N];
Adj[1].push_back(Node(3,4));
```

## 图的遍历

### 深度优先搜索（DFS)

**定义：**沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，并继续访问那些未访问分支结点。

**连通分量**：无向图中，两个顶点之间可以相互到达（可以通过一定路径间接到达）则称这两个顶点**连通**。任意两个顶点都连通，则称图 G 为**连通图**，其中的极大连通子图为**连通分量（连通块）**。（不要理解为最大的连通子图）

**强连通分量**：有向图中，两个顶点之间可以相互到达（可以通过一定路径间接到达）则称这两个顶点**强连通**。任意两个顶点都连通，则称图 G 为**强连通图**，其中的极大强连通子图为**强连通分量（连通块）**。

#### 邻接矩阵版

```c++
#include <stdio.h>
//最大顶点数
const int MAXN = 1000;
//无穷大 表示不能到达
const int INF = 1000000000;
//顶点个数 邻接矩阵
int n, G[MAXN][MAXN];
//如果顶点i已被访问 则vis[i] = true
bool vis[MAXN] = {false};

void DFS(int u, int depth)
{
	//访问u
	vis[u] = true;
    //需要对u进行一些操作 可在此处处理
	//访问u的所有分支
	for (int v = 0; v < n; v++)
	{
        //v未被访问且u可达v
		if (vis[v] == false && G[u][v] != INF)
		{
			DFS(v, depth + 1);
		}
	}
}

//遍历图G
void DFSTrave()
{
	//对每个顶点u
	for (int u = 0; u < n; u++)
	{
		//如果u未被访问
		if (vis[u] == false)
		{
			//访问u和u所在的连通块 1表示初始为第一层
			DFS(u, 1);
		}
	}
}

```

#### 邻接表版

```c++
#include <stdio.h>
#include <vector>
using namespace std;

//最大顶点数
const int MAXN = 1000;
//无穷大 表示不能到达
const int INF = 1000000000
//图G的邻接表
vector<int> Adj[MAXN];
//如果顶点i已被访问 则vis[i] = true
bool vis[MAXN] = {false};

void DFS(int u, int depth)
{
	vis[u] = true;
	//需要对u进行一些操作 可在此处处理
    //访问u的所有分支
	for (int i = 0; i < Adj[u].size(); i++)
	{
		int v = Adj[u][i];
		if (vis[v] == false)
		{
			DFS(v, depth + 1);
		}
	}
}

//遍历图G
void DFSTrave()
{
	//对每个顶点u
	for (int u = 0; u < n; u++)
	{
		//如果u未被访问
		if (vis[u] == false)
		{
			//访问u和u所在的连通块 1表示初始为第一层
			DFS(u, 1);
		}
	}
}
```

### 广度优先搜索（BFS)

#### 邻接矩阵

```c++

#include <stdio.h>

//最大顶点数
const int MAXN = 1000;
//无穷大 表示不能到达
const int INF = 1000000000;
//顶点数  图的邻接矩阵
int n， G[MAXN][MAXN];
//如果顶点i已被访问 则inq[i] = true
bool inq[MAXN] = {false};

void BFS(int u)
{
  queue<int> q;
  q.push(u);
  //设置u已被加入过队列
  inq[u] = true;
  while (!q.empty())
  {
    int u = q.front();
    //枚举u的所有相邻结点
    for (int v = 0; v < n; v++)
    {
      //如果u的领结点v未加入队列且通过u可达
      if (inq[v] == false && G[u][v] != INF)
      {
        q.push(v);
        inq[v] = true;
      }
    }
  }
}

void BFSTrave()
{
  for (int u = 0; u < n; u++)
  {
    if (inq[u] == false)
    {
      BFS(u);
    }
  }
}
```

#### 邻接表

```c++

#include <stdio.h>
#include <queue>
using namespace std;

//当需要输出层时  就要存储结点
struct node
{
  //顶点的编号
  int v;
  //顶点层号
  int layer;
};
//最大顶点数
const int MAXN = 1000;
//图的邻接表
vector<node> AdjNode[MAXN];
//如果顶点i已被访问 则inq[i] = true
bool inq[MAXN] = {false};

void BFS(int u)
{
  queue<int> q;
  q.push(u);
  inq[u] = true;
  while (!q.empty())
  {
    q.front();
    for (int i = 0; i < Adj[u].size(); i++)
    {
      if (inq[Adj[u][i]] == false)
      {
        q.push(Adj[u][i]);
        inq[Adj[u][i]] = true;
      }
    }
  }
}

//考虑层号的输出
void BFS(int s)
{
  queue<node> q;
  node start;
  start.v = s;
  start.layer = 0;
  q.push(start);
  //起始点的编号设为已被加入队列
  inq[start.v] = true;
  while (!q.empty())
  {
    //取出队首元素
    node topNode = q.front();
    q.pop();
    //顶点编号
    int u = topNode.v;
    for (int i = 0; i < AdjNode[u].size(); i++)
    {
      //从u出发能到达的顶点
      node next = AdjNode[u][i];
      next.layer = topNode.layer + 1;
      if (inq[next.v] == false)
      {
        q.push(next);
        //next的编号设为已被加入过队列
        inq[next.v] = true;
      }
    }
  }
}

void BFSTrave()
{
  for (int u = 0; u < n; u++)
  {
    if (inq[u] == false)
    {
      BFS(u);
    }
  }
}

```

## 最短路径

### Dijkstra 算法

Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。

#### 邻接矩阵实现

```c++
#include <stdio.h>

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 0x3fffffff;

//顶点数量 连接矩阵 起点到各点的最短路径长度 表示从起点到顶点v的最短路径上v的前一个顶点
int n, G[MAXV][MAXV], dis[MAXV], pre[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};

void Dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  //初始状态设置每个结点的前驱结点为自身
  for (int i = 0; i < n; i++)
  {
    pre[i] = i;
  }

  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int v = 0; v < n; v++)
    {
      //如果v未被访问 && u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF && dis[v] > G[u][v] + dis[u])
      {
        //优化dis[v]
        dis[v] = G[u][v] + dis[u];
        pre[v] = u;
      }
    }
  }
}

/**
 * @Descripttion: 输出路径
 * @param {int} s 起点
 * @param {int} v 终点
 * @return {*}
 */
void DFS(int s, int v)
{
  if (v == s)
  {
    printf("%d\n", s);
    return;
  }
  DFS(s, pre[v]);
  //从最深处return回来之后 输出每一层的顶点编号
  printf("%d\n", v);
}
```

#### 邻接表实现

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;

struct Node
{
  //v为边的目标顶点 dis为边权
  int v, dis;
};

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 0x3fffffff;

//顶点数量 起点到各点的最短路径长度 表示从起点到顶点v的最短路径上v的前一个顶点
int n, dis[MAXV], pre[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};
vector<Node> Adj[MAXV];

void dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  //初始状态设置每个结点的前驱结点为自身
  for (int i = 0; i < n; i++)
  {
    pre[i] = i;
  }
  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int j = 0; j < Adj[u].size(); j++)
    {
      //如果v未被访问 && 以u为中介到达v距离更小
      int v = Adj[u][j].v;
      if (vis[v] == false && dis[v] > Adj[u][j].dis + dis[u])
      {
        //优化dis[v]
        dis[v] = dis[u] + Adj[u][j].dis;
      }
    }
  }
}

/**
 * @Descripttion: 输出路径
 * @param {int} s 起点
 * @param {int} v 终点
 * @return {*}
 */
void DFS(int s, int v)
{
  if (v == s)
  {
    printf("%d\n", s);
    return;
  }
  DFS(s, pre[v]);
  //从最深处return回来之后 输出每一层的顶点编号
  printf("%d\n", v);
}

```

#### 考虑第二标尺的最短路径

##### 新增边权

```c++
//cost[u][v]表示u->v的花费 由题目给出
//增加一个数组c[],表示从起点到达顶点u的最少花费为c[u],只有c[s]初始化为0，其余为INF
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          c[v] = c[u] + cost[u][v];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v] && c[v] > c[u] + cost[u][v])
        {
          c[v] = c[u] + cost[u][v];
        }
      }
    }
```

##### 新增点权

```c++
//weight[u]表示u可收集的物资 由题目给出
//增加一个数组w[],表示从起点到达顶点u可收集的最大物资w[u],只有w[s]初始化为weight[s]，其余为0
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          w[v] = w[u] + weight[v];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v] && w[v] < w[u] + weight[v])
        {
          w[v] = w[u] + weight[v];
        }
      }
    }
```

##### 最短路径条数

```c++
//num[]表示s->u的最短路径条数 s:起点
//num[s] = 1 其余为0
for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          pre[v] = u;
          num[v] = num[u];
        }
          //距离相同时 看能否使c[v]更优
        else if (dis[u] + G[u][v] == dis[v])
        {
          num[v] += num[u];
        }
      }
    }
```

##### Dijkstra+DFS

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

//最大顶点数
const int MAXV = 1000;
//设置无穷大 表示两点没有连接
const int INF = 0x3fffffff;
//顶点数量 路径矩阵 起点
int n, G[MAXV][MAXV], st;
//起点到各点的最短路径长度 记录题目中添加的额外边权代价信息 从题目中获取
int dis[MAXV], cost[MAXV][MAXV], weight[MAXV];
//标记数组 vis=true表示已访问
bool vis[MAXV] = {false};
//表示从起点到顶点v的最短路径上v的前一个顶点
vector<int> pre[MAXV];

/**
 * @Descripttion: 连接矩阵实现
 * @param {int} s
 * @return {*}
 */
void Dijkstra(int s)
{
  //fill函数将整个d数组赋为INF
  fill(dis, dis + MAXV, INF);
  dis[s] = 0;
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    //使dis[u]最小的还未被访问的顶点标号
    int u = -1;
    //存放最小的d[]
    int min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    //没有找到最小的u 说明与s均不相连
    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    for (int v = 0; v < n; v++)
    {
      //如果v未被访问&& u能到达v && 以u为中介到达v距离更小
      if (vis[v] == false && G[u][v] != INF)
      {
        if (dis[v] > G[u][v] + dis[u])
        {
          //优化dis[v]
          dis[v] = G[u][v] + dis[u];
          pre[v].clear();
          pre[v].push_back(u);
        }
        else if (dis[v] == G[u][v] + dis[u])
        {
          pre[v].push_back(u);
        }
      }
    }
  }
}
//最优路径和临时路径
vector<int> path, tempPath;
//第二标尺最优值
int optValue = 0;
/**
 * @Descripttion: 输出路径
 * @param {int} v 当前访问的结点
 * @return {*}
 */
void DFS(int v)
{
  //递归边界
  if (v == st) //到达了叶子结点
  {
    tempPath.push_back(v);
    int value = 0;
    //此处添加计算第二标尺的value值
    //边权
    for (int i = tempPath.size() - 1; i > 0; i--)
    {
      //当前结点id 下一结点idNext
      int id = tempPath[i], idNext = tempPath[i - 1];
      value += cost[id][idNext];
    }
    //点权
    for (int i = tempPath.size() - 1; i >= 0; i--)
    {
      //当前结点id 下一结点idNext
      int id = tempPath[i];
      value += weight[id];
    }
    if (value < optValue)
    {
      optValue = value;
      path = tempPath;
    }
    //将刚加入的结点删除
    tempPath.pop_back();
    return;
  }
  //递归式
  tempPath.push_back(v);
  for (int i = 0; i < pre[v].size(); i++)
  {
    //结点v的前驱结点pre[v][i] 递归
    DFS(pre[v][i]);
  }

  //遍历完所有结点 删除v
  tempPath.pop_back();
}
```

### Bellman-Ford 算法

解决有负权的最短路径问题。每轮都松弛所有边，总共进行n轮

```c++
#include <cstdio>
#include <iostream>
#include <vector>
#include <set>
using namespace std;
const int MAXV = 101;
const int INF = 0x3fffffff;
struct Node
{
  int v, dis;
  Node(int _v, int _dis)
  {
    v = _v;
    dis = _dis;
  }
};
//距离起点的最短距离 顶点数量
int d[MAXV], n, num[MAXV];
//邻接表
vector<Node> Adj[MAXV];
//前驱
set<int> pre[MAXV];

bool bellmanFord(int s)
{
  fill(d, d + MAXV, INF);
  d[s] = 0;
  for (int i = 0; i < n-1; i++)
  {
    //松弛每条边
    for (int u = 0; u < n; u++)
    {
      for (int j = 0; j < Adj[u].size(); j++)
      {
        int v = Adj[u][j].v;
        if (d[v] > d[u] + Adj[u][j].dis)
        {
          d[v] = d[u] + Adj[u][j].dis;
          num[v] = num[u];
          pre[v].clear();
          pre[v].insert(u);
        }
        //如果有第二评价指标
        else if (d[v] == d[u] + Adj[u][j].dis)
        {
          pre[v].insert(u);
          num[v] = 0;
          set<int>::iterator it;
          for (it = pre[v].begin(); it != pre[v].end(); it++)
          {
            num[v] += num[*it];
          }
        }
      }
    }
  }

  //判断是否存在负环
  //判断每条边
  for (int u = 0; u < n; u++)
  {
    for (int j = 0; j < Adj[u].size(); j++)
    {
      int v = Adj[u][j].v;
      //图中有负环
      if (d[v] > d[u] + Adj[u][j].dis)
      {
        return false;
      }
    }
  }
  return true;
}
```

### SPFA算法

根据：只有当某个顶点u的d[u]改变时，从他出发的边的邻接点v的d[v]值才可能被改变，所以建立一个队列，每次将队首顶点取出，进行相应的松弛操作。

```c++
#include <stdio.h>
#include <vector>
#include <set>
#include <algorithm>
#include <string.h>
#include <queue>

using namespace std;

const int MAXN = 510;
const int INF = 0xfffffff;
struct Node
{
  int v, w;
  //构造函数
  Node(int _v, int _w) : v(_v), w(_w) {}
};

vector<Node> Adj[MAXN];
//顶点数 边数 起点 终点 点权
int n, m, st, ed, weight[MAXN];
//最短距离 最大点权之和 最短路径条数
int dis[MAXN], wMax[MAXN], num[MAXN];
//顶点是否在队列中
bool inq[MAXN];
bool SPFA(int s)
{
  //初始化
  memset(inq, false, sizeof(inq));
  memset(num, 0, sizeof(num));
  fill(dis, dis + MAXN, INF);
  //源点入队
  queue<int> q;
  q.push(s);
  inq[s] = true;
  num[s]++;
  dis[s] = 0;
  while (!q.empty())
  {
    int u = q.front();
    q.pop();
    inq[u] = false;
    //遍历u的所有邻接边
    for (int j = 0; j < n; j++)
    {
      //邻接边的顶点
      int v = Adj[u][j].v;
      int w = Adj[u][j].w;
      //松弛操作
      if (dis[u] + w < dis[v])
      {
        dis[v] = dis[u] + w;
        if (!inq[v])
        {
          q.push(v);
          inq[v] = true;
          num[v]++;
          if (num[v] >= n)
          {
            return false; //有可达负环
          }
        }
      }
    }
  }
  return true; //无可达负环
}
```

## 最小生成树



## 关键路径

## AOV网

顶点表示活动，边集表示活动间优先关系的有向图；

## AOE网

带权的边集表示活动，顶点表示事件的有向图；边权表示活动完成所需时间。

## 关键路径

AOE网中最长路径被称为关键路径（即影响整个路径）

## 最小生成树

一个给定的无向图中求一棵树，使得这棵树拥有图中所有顶点，且边权之和最小。

**性质**

1. 最小生成树是树，因此其边数等于顶点数减 1，且树内一定不会有环；
2. 对给定的图 G(V,E)，其最小生成树可以不唯一，但是边权之和一定是唯一的；
3. 由于最小生成树是在无向图上生成的，因此根节点可以是这棵树上的任意一个结点。

### prim 算法--边多的情况

**基本思想：**对图设置集合 S，存放已被访问的顶点，然后每次从集合 V-S 中选择与集合 S 的最短距离最小的一个顶点 u，访问并加入集合 S。之后，令顶点 u 为中介点，优化所有从 u 能到达的顶点 v 与集合 S 之间的最短距离。重复 n 次（n 为顶点个数），直到 S 中包含所有顶点。

#### 邻接矩阵版

```c
#include <stdio.h>
#include <algorithm>
using namespace std;

const int MAXN = 1000;
const int INF = 100000000;

int n, G[MAXN][MAXN];
//顶点与集合的最短距离
int dis[MAXN];
//标记是否被加入到集合中
bool vis[MAXN];

/**
 * @Descripttion: 默认0号位初始点
 * @param {*}
 * @return {*} 最小生成树的边权之和
 */
int prim()
{
  fill(dis, dis + MAXN, INF);
  dis[0] = 0;
  //存放最小生成树的边权之和
  int ans = 0;
  for (int i = 0; i < n; i++)
  {
    int u = -1, min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }

    if (u == -1)
    {
      return;
    }
    vis[u] = true;
    //将与集合最小的边加入最小生成树
    ans += dis[u];
    for (int v = 0; v < n; v++)
    {
      if (vis[v] == false && G[u][v] != INF && dis[v] > G[u][v])
      {
        //与Dijkstra相比 不是到起点的距离 而是到集合的距离
        dis[v] = G[u][v];
      }
    }
  }
  return ans;
}
```

#### 邻接表版

```c++
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int MAXN = 100;
const int INF = 100000;
bool vis[MAXN] = {false};
int ans, n, dis[MAXN];

struct node
{
  int v, d;
};
vector<node> Adj[MAXN];
int prime()
{
  //默认0号为顶点
  dis[0] = 0;
  fill(dis, dis + MAXN, INF);
  //n个顶点 循环n次
  for (int i = 0; i < n; i++)
  {
    int u = -1, min = INF;
    for (int j = 0; j < n; j++)
    {
      if (vis[j] == false && dis[j] < min)
      {
        u = j;
        min = dis[j];
      }
    }
    if (u == -1)
    {
      return -1;
    }
    ans += dis[u];
    vis[u] = true;
    for (int j = 0; j < Adj[u].size(); j++)
    {
      int v = Adj[u][j].v;
      if (vis[v] == false && Adj[u][j].d < dis[v])
      {
        dis[v] = Adj[u][j].d;
      }
    }
  }
  return ans;
}
```

### kruskal 算法--点多的情况

#### 基本思想

1. 对所有边按边权从小到大排序；
2. 按照排序后的结果测试所有边，如果当前边的两个端点不在同一个连通块，则把这条边加到最小生成树中，否则，舍弃该边；
3. 执行步骤 2，直到最小生成树的边数等于总顶点数减 1 或者是测试完所有边时结束。如果最小生成树的边数小于总顶点数减 1，说明该图不连通。

#### 代码实现

```c++
#include <stdio.h>
#include <algorithm>
using namespace std;
const int MAXN = 110;
const int MAXE = 10010;
struct edge
{
  //边的两个端点编号
  int u, v;
  //边权
  int cost;
} E[MAXE]; //最多有MAXE条边

bool cmp(edge a, edge b)
{
  return a.cost < b.cost;
}

//并查集部分
int father[MAXN];
int findFather(int x)
{
  int a = x;
  while (x != father[x])
  {
    x = father[x];
  }

  //路径压缩
  while (a != father[a])
  {
    int z = a;
    a = father[a];
    father[z] = x;
  }
  return x;
}

/**
 * @Descripttion:
 * @param {int} n 顶点个数
 * @param {int} m 边数
 * @return {*}
 */
int kruskal(int n, int m)
{
  //边权之和 边的个数
  int ans = 0, edgeNum = 0;
  //并查集初始化--假设顶点从0开始编号
  for (int i = 0; i < n; i++)
  {
    father[i] = i;
  }
  sort(E, E + m, cmp);
  //枚举所有的边
  for (int i = 0; i < n; i++)
  {
    int faU = findFather(E[i].u);
    int faV = findFather(E[i].v);
    //不在一个集合中
    if (faU != faV)
    {
      //合并集合 即把测试边加入最小生成树
      father[faU] = faV;
      ans += E[i].cost;
      edgeNum++;
      if (edgeNum == n - 1)
        break;
    }
  }
  if (edgeNum != n - 1)
    return -1;
  else
  {
    return ans;
  }
}
```

### 拓扑排序

将有向无环图 G 的所有顶点排成一个线性序列，使得对图 G 中的任意两个顶点 u，v，如果存在 u->v，那么在序列中 u 一定在 v 前面。这个序列被称为拓扑序列。

#### 实现步骤

1. 定义一个队列 Q，并把所有入度为 0 的结点加入队列；
2. 取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减 1，如果某个顶点的入度减为 0，则将其加入队列；
3. 反复进行 2 操作，直到队列为空。如果队列为空时入过队的结点数目恰好为 N，说明拓扑排序成功，图 G 为有向无环图；否则，拓扑排序失败，图 G 中有环。

#### 代码实现

```c++
#include <stdio.h>
#include <vector>
#include <queue>
using namespace std;
const int MAXV = 1000;

vector<int> G[MAXV];

//顶点数 入度
int n, m, inDegree[MAXV];

//拓扑排序
bool topologicalSort()
{
  //记录加入拓扑序列的顶点数
  int num = 0;
  queue<int> q;
  for (int i = 0; i < n; i++)
  {
    //将所有入度为0的顶点入队
    if (inDegree[i] == 0)
    {
      q.push(i);
    }
  }
  while (!q.empty())
  {
    int u = q.front();
    //此处可以输出顶点u 作为拓扑序列中的顶点
    // printf("%d", u);
    q.pop();
    for (int i = 0; i < G[u].size(); i++)
    {
      int v = G[u][i];
      //顶点v的入度减1
      inDegree[v]--;
      if (inDegree[v] == 0)
      {
        q.push(v);
      }
    }
    //清空顶点u的出边(如务必要可不写)
    G[u].clear();
    num++;
  }

  if (num == n)
  {
    return true;
  }
  else
  {
    return false;
  }
}
```

### 关键路径

#### AOV 网（Activity On Vertex）

顶点表示活动，边集表示活动间优先关系的有向图。

#### AOE 网（Activity On Edge）

带权的边集表示活动（边权表示活动需要的时间），顶点表示事件的有向图。

#### 关键路径

AOE 网中最长路径别称为关键路径

# 树

## 二叉树基本操作

```c++
#include <stdio.h>
#include <stdlib.h>
struct node
{
  int data;
  node *lchild;
  node *rchild;
};

//根节点为空
node *root = NULL;

/**
 * @Descripttion: 生成一个新节点
 * @param {int} v 新节点的权值
 * @return {*}
 */
node *newNode(int v)
{
  node *newNode = (node *)malloc(sizeof(node));
  newNode->data = v;
  newNode->lchild = newNode->rchild = NULL;
  return newNode;
}

/**
 * @Descripttion: 修改数据域为x的结点值为newData
 * @param {node} *root
 * @param {int} x
 * @param {int} newData
 * @return {*}
 */
void modify(node *root, int x, int newData)
{
  if (root == NULL)
  {
    return;
  }
  if (root->data == x)
  {
    root->data = newData;
  }
  //往左子树递归查找
  modify(root->lchild, x, newData);
  modify(root->rchild, x, newData);
}

/**
 * @Descripttion: 插入结点
 * @param {int} val
 * @return {*}
 */
/**
 * 特别注意root使用了引用，即在函数中对root的修改会改变原变量的值
 * 如果不使用引用，root = newNode(val)这个语句对root的修改就不能
 * 作用到原变量（即上一层root->lchild与root->rchild） 即不能把
 * 新结点连接到二叉树上
 * ！！！如果函数中需要新建结点，即对二叉树的结构进行改变，就需要加引用
 * 只是修改当前已有结点的内容，或是遍历 不需要加引用
 */
void insert(node *&root, int val)
{
  //空树  说明查找失败 即插入位置
  if (root == NULL)
  {
    root = newNode(val);
    return;
  }

  //由二叉树的性质，val应该插在左子树
  if (root->lchild)
  {
    insert(root->lchild, val);
  }
  //由二叉树的性质，val应该插在右子树
  else
  {
    insert(root->rchild, val);
  }
}

/**
 * @Descripttion: 二叉树的创建
 * @param {int} data
 * @param {int} n
 * @return {*}
 */
node* creatBinaryTree(int data[], int n){
  node *root = NULL;
  for (int i = 0; i < n; i++)
  {
    insert(root, data[i]);
  }
  return root;
}
```

## 二叉树的遍历

先序遍历

```c
void preOrder(node *root)
{
  if (root == NULL) //到达空树，递归边界
  {
    return;
  }
  //访问根结点
  printf("%d\n", root->data);
  //访问左子树
  preOrder(root->lchild);
  //访问右子树
  preOrder(root->rchild);
}
```

中序遍历

```c
void inOrder(node *root)
{
  if (root == NULL) //到达空树，递归边界
  {
    return;
  }
  //访问左子树
  inOrder(root->lchild);
  //访问根结点
  printf("%d\n", root->data);
  //访问右子树
  inOrder(root->rchild);
}
```

后序遍历

```c
void postOrder(node *root)
{
  if (root == NULL) //到达空树，递归边界
  {
    return;
  }
  //访问左子树
  postOrder(root->lchild);
  //访问右子树
  postOrder(root->rchild);
  //访问根结点
  printf("%d\n", root->data);
}
```

层序遍历

```c
void layerOrder(node *root)
{
  //队列里存放地址-->实现对原元素的修改
  queue<node *> q;
  root->layer = 1;
  q.push(root);
  while (!q.empty())
  {
    //取出队首元素
    node *temp = q.front();
    printf("%d", temp->data);
    q.pop();
    //左子树非空
    if (temp->lchild)
    {
      temp->lchild->layer = temp->layer + 1;
      q.push(temp->lchild);
    }
    //右子树非空
    if (temp->rchild)
    {
      temp->rchild->layer = temp->layer + 1;
      q.push(temp->rchild);
    }
  }
}
```

## 静态写法

```c++
struct node
{
  int data;
  //指针域 存放所有子结点的下标
  vector<int> child;
  //层数
  int layer;
} Node[MAXN];
```

先序遍历

```c++
void preOrder(int root)
{
  printf("%d ", root);
  for (int i = 0; i < Node[root].child.size(); i++)
  {
    preOrder(Node[root].child[i]);
  }
}
```

层序遍历

```c++
void layerOrder(int root)
{
  queue<int> q;
  //根节点的层号为1
  Node[root].layer = 1;
  q.push(root);
  while (!q.empty())
  {
    int top = q.front();
    printf("%d ", Node[top].data);
    q.pop();
    for (int i = 0; i < Node[top].child.size(); i++)
    {
      //当前结点的第i个子结点的编号
      int child = Node[top].child[i];
      Node[child].layer = Node[top].layer + 1;
      q.push(child);
    }
  }
}
```



## 二叉查找树（BST)

### **二叉排序树介绍**

1. **二叉排序树**：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求**左子节点**的值**比当前**节点的值**小**，**右**子节点的值**比当前**节点的值**大**。左子树(根节点左边)的值 ≤ 根节点的值；右子树的值 ≥ 根节点的值。

2. 特别说明：如果有**相同的值**，可以将该节点放在**左**子节点**或右**子节点

3. 二叉排序树不唯一（根节点不同）

### 基本操作

**查找**

```c
void search(node *root, int val)
{

  if (root == NULL)
  {
    printf("failed\n");
    return;
  }
  if (root->data == val)
  {
    printf("%d", root->data);
  }
  //往右子树递归查找
  else if (root->data < val)
  {
    search(root->rchild, val);
  }
  //往左子树递归查找
  else
  {
    search(root->lchild, val);
  }
}
```

插入

```c
void insert(node *&root, int val)
{

  if (root == NULL)
  {
    node *root = new node();
    root->data = val;
    return;
  }
  if (root->data == val)
  {
    return;
  }
  //往右子树递归插入
  if (root->data < val)
  {
    insert(root->rchild, val);
  }
  else
  {
    insert(root->lchild, val);
  }
}
```

**删除**

```c++
/**
 * @Descripttion: 寻找以root为根结点的树中的最大权值结点
 * @param {*}
 * @return {*}
 */
node *findMax(node *root)
{
  //!!! 如果是查找原始二叉排序树根结点的最大权值结点
  //root应该为原始二叉排序树根结点的左结点
  while (root->rchild != NULL)
  {
    root = root->rchild;
  }
  return root;
}

node *findMin(node *root)
{
  while (root->lchild != NULL)
  {
    root = root->lchild;
  }
  return root;
}

/**
 * @Descripttion: 删除算法
 * @param {int} val
 * @return {*}
 */
void deleteNode(node *&root, int val)
{
  if (root == NULL)
    return;
  if (root->data == val)
  {
    if (root->lchild == NULL && root->rchild == NULL)
    {
      //没有左右子结点  直接删除
      root = NULL;
    }
    //左子树不为空
    else if (root->lchild != NULL)
    {
      node *pre = findMax(root->lchild);
      root->data = pre->data;
      //在左子树删除结点pre
      deleteNode(root->lchild, pre->data);
    }
    else
    {
      node *next = findMin(root->rchild);
      root->data = next->data;
      //在右子树删除结点next
      deleteNode(root->rchild, next->data);
    }
  }
  else if (root->data > val)
  {
    deleteNode(root->lchild, val);
  }
  else
  {
    deleteNode(root->rchild, val);
  }
}
```

## 平衡二叉树(AVL)

### 平衡二叉树介绍

**平衡二叉树**也叫**平衡二叉搜索树**（Self-balancing binary search tree）又被称为**AVL 树**， 可以保证查询效率较高。

具有以下特点：

1. 它是一棵空树或它的左右两个子树的**高度差的绝对值不超过 1**；
2. 左右两个子树都是一棵平衡二叉树；
3. 平衡二叉树的常用实现方法有**红黑树、AVL、替罪羊树、Treap、伸展树**等。

### 基本操作

查找

```c
void search(node *root, int val)
{
  if (root == NULL)
  {
    return;
  }
  if (root->data == val)
  {
    printf("%d", root->data);
  }
  else if (root->data > val)
  {
    search(root->lchild, val);
  }
  else
  {
    search(root->rchild, val);
  }
}
```

插入

```c++
#include <stdio.h>
#include <algorithm>
using namespace std;
struct node
{
  int data;
  //以当前结点为根节点子树的高度
  int height;
  node *lchild, *rchild;
};

/**
 * @Descripttion: 新建一个结点 
 * @param {int} val
 * @return {*}
 */
node *newNode(int val)
{
  //申请一个node型变量的地址空间
  node *Node = new node;
  Node->data = val;
  Node->height = 1;
  Node->lchild = Node->rchild = NULL;
  return Node;
}

//获取root所在子树的当前高度
int getHeight(node *root)
{
  if (root == NULL)
    return 0;
  return root->height;
}

int getBalanceFactor(node *root)
{
  //左子树高度减去右子树高度
  return getHeight(root->lchild) - getHeight(root->rchild);
}

void updateHeight(node *root)
{
  //当前结点的高度等于左右子树高度最大值 + 1
  root->height = max(getHeight(root->lchild), getHeight(root->rchild)) + 1;
}

/**
 * @Descripttion: 左旋
 * @param {node} *root
 * @return {*}
 */
void leftRotation(node *root)
{
  //定义一个结点保存根结点的右子结点
  node *newRoot = root->rchild;
  root->rchild = root->rchild->lchild;
  newRoot->lchild = root;
  //更新旋转完之后相关结点高度
  updateHeight(newRoot);
  updateHeight(root);
  //根结点指向原根结点的右子结点
  root = newRoot;
}

/**
 * @Descripttion: 右旋
 * @param {node} *root
 * @return {*}
 */
void rightRotation(node *root)
{
  //定义一个结点保存根结点的左子结点
  node *newRoot = root->lchild;

  root->lchild = newRoot->rchild;
  newRoot->rchild = root;
  //更新旋转完之后相关结点高度
  updateHeight(newRoot);
  updateHeight(root);
  //根结点指向原根结点的左子结点
  root = newRoot;
}

void insert(node *&root, int val)
{
  if (root == NULL)
  {
    root = newNode(val);
    return;
  }
  if (root->data > val)
  {
    //往左子树插入
    insert(root->lchild, val);
    //跟新高度
    updateHeight(root);
    if (getBalanceFactor(root) == 2)
    {
      //需要右旋
      if (getBalanceFactor(root->lchild) == 1)
      {
        rightRotation(root);
      }
      else if (getBalanceFactor(root->lchild) == -1)
      { //左右旋
        leftRotation(root->lchild);
        rightRotation(root);
      }
    }
  }
  else
  {
    //往右子树插入
    insert(root->rchild, val);
    updateHeight(root);
    if (getBalanceFactor(root) == -2)
    {
      if (getBalanceFactor(root->rchild) == -1)
      {
        leftRotation(root);
      }
      else if (getBalanceFactor(root->rchild) == 1)
      { //右左旋
        rightRotation(root->rchild);
        leftRotation(root);
      }
    }
  }
}

node *creat(int data[], int n)
{
  node *root = NULL; //新建空根结点root
  for (int i = 0; i < n; i++)
  {
    insert(root, data[i]);
  }
  return root;
}

```

建立

```c++
node *creat(int data[], int n)
{
   //新建空根结点root
  node *root = NULL;
  for (int i = 0; i < n; i++)
  {
    insert(root, data[i]);
  }
  return root;
}
```

# 并查集


## 前言

用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02943a90-7dd4-4e9a-9325-f8217d3cc54d.jpg" width="350"/> </div><br>

|              方法               |           描述            |
| :-----------------------------: | :-----------------------: |
|            UF(int N)            | 构造一个大小为 N 的并查集 |
|    void union(int p, int q)     |     连接 p 和 q 节点      |
|         int find(int p)         | 查找 p 所在的连通分量编号 |
| boolean connected(int p, int q) | 判断 p 和 q 节点是否连通  |

```java
public abstract class UF {

    protected int[] id;

    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public abstract int find(int p);

    public abstract void union(int p, int q);
}
```

## Find

```c
//初始化
void init(int n){
	for(int i = 1; i <= n; i++){
	father[i] = i;
}
int findFather(int x){
	while(x != father[x]){
		x = father[x];
	}
	return x;
}
```

## Quick Find

可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。

**需要保证同一连通分量的所有节点的 id 值相等**，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。

但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0972501d-f854-4d26-8fce-babb27c267f6.jpg" width="320"/> </div><br>

```java
public class QuickFindUF extends UF {

    public QuickFindUF(int N) {
        super(N);
    }


    @Override
    public int find(int p) {
        return id[p];
    }


    @Override
    public void union(int p, int q) {
        int pID = find(p);
        int qID = find(q);

        if (pID == qID) {
            return;
        }

        for (int i = 0; i < id.length; i++) {
            if (id[i] == pID) {
                id[i] = qID;
            }
        }
    }
}
```

## Union

```c
//集合的合并 
void Union(int a, int b){
	int faA = findFather(a);
	int faB = findFather(b);
	if(faA != faB){
		father[faA] = faB;
	}
}
```

## Quick Union

可以快速进行 union 操作，只需要修改一个节点的 id 值即可。

但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11b27de5-5a9d-45e4-95cc-417fa3ad1d38.jpg" width="280"/> </div><br>

```java
public class QuickUnionUF extends UF {

    public QuickUnionUF(int N) {
        super(N);
    }


    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }


    @Override
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot != qRoot) {
            id[pRoot] = qRoot;
        }
    }
}
```

这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23e4462b-263f-4d15-8805-529e0ca7a4d1.jpg" width="100"/> </div><br>

## 加权 Quick Union

为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会**让较小的树连接较大的树上面**。

理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9f18f8a-c1ea-422e-aa56-d91716b0f755.jpg" width="150"/> </div><br>

```java
public class WeightedQuickUnionUF extends UF {

    // 保存节点的数量信息
    private int[] sz;

    public WeightedQuickUnionUF(int N) {
        super(N);
        this.sz = new int[N];
        for (int i = 0; i < N; i++) {
            this.sz[i] = 1;
        }
    }

    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    @Override
    public void union(int p, int q) {

        int i = find(p);
        int j = find(q);

        if (i == j) return;

        if (sz[i] < sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        } else {
            id[j] = i;
            sz[i] += sz[j];
        }
    }
}
```

## 路径压缩

```c
//路径的压缩
void compressPath(int x){
	//x最终被迭代成根结点  临时变量先保存x的值
	int a = x;
	while(x != father[x]){
		x = father[x];
	} 
	
	while(a != father[a]){
		int z = a;
		a = father[a];
		father[z] = x;
	}
} 
```



## 路径压缩的加权 Quick Union

在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。

## 比较

|            算法            |   union    |    find    |
| :------------------------: | :--------: | :--------: |
|         Quick Find         |     N      |     1      |
|        Quick Union         |    树高    |    树高    |
|      加权 Quick Union      |    logN    |    logN    |
| 路径压缩的加权 Quick Union | 非常接近 1 | 非常接近 1 |



# 散列表

## 直接寻址表

## 散列表

## 散列函数

### 除法散列法

### 乘法散列法

### 全域散列法

## Hash 冲突解决

### 开放寻址法

#### 线性探查法

不断探查后边的位置，超过表长时从表头开始，直达遇到空位置

缺点：元素容易扎堆

#### 平方探查法

按照 H(key) + 1^2、H(key) - 1^2、H(key) + 2^2、H(key) - 2^2...如果超过了表长，就把 H(key) + k^2 对 TSize(表长)取模，如果 H(key) - k^2 < 0，将((H(key) - k^2) % TSize + TSize) % TSize 作为结果(等价于 H(key) - k^2 不断加上 TSize，直到出现非负数)

### 链地址法

把所有 H(key)相同的 key 连接成一条单链表。

## 完全散列

## 字符串 hash

```c
//字符串全为大写字母的hash转换-->将26个字母等效成1-26
int hashFunc(int str[], int len){
	int val = 0;
    for(int i = 0; i < len; i++){
        val = val * 26 + (str[i] - 'A' );
    }
    return val;
}
```

# 递归

## 递归边界

返回最简单底层的结果

## 递归式

减少数据规模并向下一层递归

# 查找

## 深度优先搜索(DFS)

题目

有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品总重量和不超过V的前提下，让背包中物品的价值之和最大，求最大值。

C代码

```c
#include <stdio.h>

//物品件数 背包重量 最大价值
int n, V, maxValue = 0;
//w[i] 为每件物品重量 c[i]为每件物品价值
int w[30], c[30];

void DFS(int index, int sumW, int sumC)
{
  //递归边界 完成对n件商品的选择
  if (index == n)
  {
    return;
  }

  //不选择第index件上商品
  DFS(index + 1, sumW, sumC);
  if (sumW + w[index] <= V)
  {
    if (sumC + c[index] > maxValue)
    {
      maxValue = sumC + c[index];
    }
    //选择第index+1件商品
    DFS(index + 1, sumW + w[index], sumC + c[index]);
  }
}

int main(int argc, char const *argv[])
{
  scanf("%d%d", &n, &V);
  for (int i = 0; i < n; i++)
  {
    scanf("%d", &w[i]);
  }

  for (int i = 0; i < n; i++)
  {
    scanf("%d", &c[i]);
  }

  DFS(0, 0, 0);
  printf("%d\n", maxValue); // 10
  return 0;
}

/**input
5 8
3 5 1 2 2
4 5 2 1 3
 */
```

题目

给定N个整数（可能有负数），从中选择K个数，使得这K个数之和恰好等于一个给定的整数X；如果有多种方案，选择他们中元素平方和最大的一个。

## 二分法

### 二分查找

要求序列递增，时间复杂度为 log(n)，二分查找过程与序列的下标从 0 或者 1 开始无关；

```c
//寻找递增数列arr中是否包含val
//二分区间为左闭右闭的[]
int binarySearch(int arr[], int right, int val)
{
    int left;
    int mid;
    while (left <= right)
    {
        // int mid = (left + right) / 2;
        mid = left + (right - left) / 2; //避免溢出
        if (arr[mid] == val)
            return mid;
        else if (arr[mid] > val)
            right = mid - 1;
        else
            left = mid + 1;
    }

    return -1;
}
```

**递增序列中第一个大于等于 x 的元素的位置**

```c
int lower_bound(int arr[], int left, int right, int x)
{
  int mid;
  //left == right 意味着找到唯一解
  while (left < right)
  {
    //防止溢出
    mid = left + (right - left) / 2;
    //arr[mid] >= x 说明第一个大于等于x的位置一定在mid处或者mid的左侧
    if (arr[mid] >= x)
    {
      right = mid;
    }
    else
    {
      left = mid + 1;
    }
  }
  return left;
}
```

**递增序列中第一个大于 x 的元素的位置**

```c
//二分上界为n 不是n-1 “即使不存在 返回的也是即使存在，应该存放的位置”
int upper_bound(int arr[], int left, int right, int x)
{
  int mid;
  //left == right 意味着找到唯一解
  while (left < right)
  {
    //防止溢出
    mid = left + (right - left) / 2;
    //arr[mid] > x 说明第一个大于x的位置一定在mid处或者mid的左侧
    if (arr[mid] > x)
    {
      right = mid;
    }
    else
    {
      left = mid + 1;
    }
  }
  return left;
}
```

### 模板

```c++
//解决“寻找有序序列第一个满足某条件的元素的位置”问题固定模板
//二分区间为左闭右闭[left, right]，初值必须能覆盖所有的可能取值
int solve(int left, int right)
{
  int mid;
  //left == right 意味着找到唯一解
  while (left < right)
  {
    //防止溢出
    mid = left + (right - left) / 2;
    //条件成立 第一个满足条件的位置<=mid
    if (条件成立)
    {
      right = mid;
    }
    else
    {
      left = mid + 1;
    }
  }
  return left;
}
```

# 贪心算法

贪心算法不能保证每次都找到最优解；

贪心算法设计：

1. 将最优化问题转化为：对其做出一次选择后，只剩下一个子问题需要求解；
2. 证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的；
3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题最优解，这样就得到最优子结构。

性质

**最优子结构：**如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构；

# 动态规划算法

**重叠子问题**：一个问题被分解为若干子问题，且这些子问题会重复出现。

**最优子结构**：一个问题的最优解可以由其子问题的最优解有效构造出来，称该问题拥有最优子结构；

**状态的无后效性**：当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。

分治与动态：分治算法不涉及重叠子问题，且分治法解决的问题不一定是最优化问题。

## Case

### 最大连续子序列和

```c++
#include <stdio.h>
#include <algorithm>
using namespace std;

const int MAXN = 10010;
//子序列个数 子序列权值 以arr[i]结尾的最长子序列
//dp[i]存放以A[i]结尾的连续序列的最大和
int n, arr[MAXN], dp[MAXN];

int main()
{

  scanf("%d", &n);
  for (int i = 0; i < n; i++)
  {
    scanf("%d", &arr[i]);
  }

  //递归边界
  dp[0] = arr[0];
  for (int i = 1; i < n; i++)
  {
    dp[i] = max(arr[i], dp[i - 1] + arr[i]);
  }
  int maxIndex = 0;
  for (int i = 1; i < n; i++)
  {
    if (dp[i] > dp[maxIndex])
    {
      maxIndex = i;
    }
  }

  printf("%d\n", dp[maxIndex]);
  return 0;
}
```



# 回溯法
